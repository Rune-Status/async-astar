<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Async-astar by tssweeney</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Async-astar</h1>
        <p>An asynchronous, generic A*(a-star) solver.</p>

        <p class="view"><a href="https://github.com/tssweeney/async-astar">View the Project on GitHub <small>tssweeney/async-astar</small></a></p>


        <ul>
          <li><a href="https://github.com/tssweeney/async-astar/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/tssweeney/async-astar/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/tssweeney/async-astar">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p><a href="https://nodei.co/npm/async-astar/"><img src="https://nodei.co/npm/async-astar.png?downloads=true" alt="NPM"></a></p>

<h1>
<a id="async-astar-" class="anchor" href="#async-astar-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Async-Astar <a href="https://travis-ci.org/tssweeney/async-astar"><img src="https://travis-ci.org/tssweeney/async-astar.svg" alt="Build Status"></a>
</h1>

<p><strong><a href="http://timssweeney.com/async-astar/src/AsyncAstar.js.html">View Documentation</a></strong></p>

<p><strong><a href="http://en.wikipedia.org/wiki/A*_search_algorithm">Read About A*(A-Star) Algorithm Here</a></strong></p>

<p>This module provides an asynchronous, generic A* implementation that can be used to solve various puzzles, games, or graph traversals. There are 2 main concepts to understand: neighbors and heuristics. Check out the tests for usage examples, but here is a quick overview:</p>

<h3>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h3>

<pre><code>var AsyncAstar = require('async-astar');
var options = {
  initial: {StateObject}
  neighbors: {Function},
  [heuristic]: {Function},
  [timeout]: {Integer},
  onComplete: {Function},
  [onTimeout]: {Function}
}
var solver = new AsyncAstar(options);
</code></pre>

<h5>
<a id="stateobject-object" class="anchor" href="#stateobject-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>StateObject {Object}</h5>

<p>An object used by the solving algorithm to represent a single state in the puzzle/game/graph. The three required fields are:</p>

<ul>
<li>id {String} Uniquely identifies puzzle/game state</li>
<li>state {Integer} -1|0|1 Impossible|Playing|Win respectively. This a-star solver can handle impossible cases (perhaps a wall, or a pit of doom).</li>
<li>action {String|Integer} This is the last "thing" you had to do to get to this state. Upon solving the puzzle, the returned "path" is an array of the action attributes of the most efficient path. It might be a cardinal direction, a key-press, something that would work like this:</li>
</ul>

<pre><code>MyGame.takeAction(0);
MyGame.getState();
// -&gt;
// {... action: 0 ...}
</code></pre>

<p>Additionally, if you need to store information that is needed to determine a state's neighbors or heuristic, append those attributes to this object. This might be x/y coordinates of your player.</p>

<h5>
<a id="initial-stateobject" class="anchor" href="#initial-stateobject" aria-hidden="true"><span class="octicon octicon-link"></span></a>initial {StateObject}</h5>

<p>An object that represents the initial state to solve from.</p>

<pre><code>initial: {
    id: "x1y5"
    state: 0,
    // action is null, because it is the starting state. Nothing came before.
    action: null,
    x: 1,   
    y: 5
}
</code></pre>

<h5>
<a id="neighbors-function" class="anchor" href="#neighbors-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>neighbors {Function}</h5>

<p>A function that accepts a single StateObject as the only parameter and returns an array of neighbors. For example:</p>

<pre><code>neighbors: function(state){
    var neighborStates = [];
    MyGame.setPlayer({
        x: state.x,
        y: state.y
    });
    neighborStates.push(MyGame.moveUp.getState());
    neighborStates.push(MyGame.moveRight.getState());
    neighborStates.push(MyGame.moveDown.getState());
    neighborStates.push(MyGame.moveLeft.getState());
    return neighborStates;
}
</code></pre>

<p>Note, let's say that there is a game-rule (business rule of the game - maybe a wall or something) that is stopping the player from moving up. <code>The MyGame.moveUp.getState()</code> call should return a StateObject that has the same <code>id</code> as the original state. The A* algorithm can then understand that the move resulted in the same state. This is also how the algorithm resolves circular paths. </p>

<h5>
<a id="optional-heuristic-function" class="anchor" href="#optional-heuristic-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>[optional] heuristic {Function}</h5>

<p>A function that accepts a single StateObject as the only parameter and returns an integer - the lower the value, the better. A heuristic is an estimation of "closeness" to the end and defaults to a function returning 0 for all states. Read more about the principles of a heuristic here: <a href="http://en.wikipedia.org/wiki/A*_search_algorithm#Admissibility_and_optimality">wiki</a>. For example:</p>

<pre><code>heuristic: function(state) {
    var endLocation = MyGame.getEndLocation();
    return Math.abs(state.x - endLocation.x) + Math.abs(state.y - endLocation.y)
}
</code></pre>

<h5>
<a id="optional-timeout-integer" class="anchor" href="#optional-timeout-integer" aria-hidden="true"><span class="octicon octicon-link"></span></a>[optional] timeout {Integer}</h5>

<p>Number of milliseconds before timeout is called and solving halts. Defaults to no timeout.</p>

<h5>
<a id="oncomplete-function" class="anchor" href="#oncomplete-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>onComplete {Function}</h5>

<p>Function that is called once the solution has been found. It accepts a single argument that will have 3 attributes:</p>

<ul>
<li>success {Boolean} if the puzzle was solved</li>
<li>path {Array} of <code>action</code> attributes of each state to get to solution</li>
<li>cost {Integer} count of actions needed (path.length - 1)</li>
</ul>

<pre><code>onComplete: function(result) {
    if (result.success) {
        console.log("The steps(" + result.cost + ") required to solve the puzzle are: ", result.path);
    } else {
        console.log("There is no solution to the puzzle.");
    }
}
</code></pre>

<h5>
<a id="optional-ontimeout-function" class="anchor" href="#optional-ontimeout-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>[optional] onTimeout {Function}</h5>

<p>Called if the solver times out. No parameters needed.</p>

<pre><code>onTimeout: function(){
    console.log("Solver timed out.");
}
</code></pre>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/tssweeney">tssweeney</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>