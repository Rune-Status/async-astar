{"name":"Async-astar","tagline":"An asynchronous, generic A*(a-star) solver.","body":"[![NPM](https://nodei.co/npm/async-astar.png?downloads=true)](https://nodei.co/npm/async-astar/)\r\n\r\nAsync-Astar \r\n===\r\n\r\n[![Build Status](https://travis-ci.org/tssweeney/async-astar.svg)](https://travis-ci.org/tssweeney/async-astar)\r\n\r\n**[View Documentation](http://timssweeney.com/async-astar/src/AsyncAstar.js.html)**\r\n\r\n**[Read About A\\*(A-Star) Algorithm Here](http://en.wikipedia.org/wiki/A*_search_algorithm)**\r\n\r\nThis module provides an asynchronous, generic A\\* implementation that can be used to solve various puzzles, games, or graph traversals. There are 2 main concepts to understand: neighbors and heuristics. Check out the tests for usage examples, but here is a quick overview:\r\n\r\n### Usage\r\n\r\n```\r\nvar AsyncAstar = require('async-astar');\r\nvar options = {\r\n  initial: {StateObject}\r\n  neighbors: {Function},\r\n  [heuristic]: {Function},\r\n  [timeout]: {Integer},\r\n  onComplete: {Function},\r\n  [onTimeout]: {Function}\r\n}\r\nvar solver = new AsyncAstar(options);\r\n```\r\n\r\n##### StateObject {Object}\r\nAn object used by the solving algorithm to represent a single state in the puzzle/game/graph. The three required fields are:\r\n\r\n* id {String} Uniquely identifies puzzle/game state\r\n* state {Integer} -1|0|1 Impossible|Playing|Win respectively. This a-star solver can handle impossible cases (perhaps a wall, or a pit of doom).\r\n* action {String|Integer} This is the last \"thing\" you had to do to get to this state. Upon solving the puzzle, the returned \"path\" is an array of the action attributes of the most efficient path. It might be a cardinal direction, a key-press, something that would work like this:\r\n\r\n```\r\nMyGame.takeAction(0);\r\nMyGame.getState();\r\n// ->\r\n// {... action: 0 ...}\r\n```\r\n\r\nAdditionally, if you need to store information that is needed to determine a state's neighbors or heuristic, append those attributes to this object. This might be x/y coordinates of your player.\r\n\r\n##### initial {StateObject}\r\nAn object that represents the initial state to solve from.\r\n\r\n```\r\ninitial: {\r\n\tid: \"x1y5\"\r\n\tstate: 0,\r\n\t// action is null, because it is the starting state. Nothing came before.\r\n\taction: null,\r\n\tx: 1,\t\r\n\ty: 5\r\n}\r\n```\r\n\r\n##### neighbors {Function}\r\nA function that accepts a single StateObject as the only parameter and returns an array of neighbors. For example:\r\n\r\n```\r\nneighbors: function(state){\r\n\tvar neighborStates = [];\r\n\tMyGame.setPlayer({\r\n\t\tx: state.x,\r\n\t\ty: state.y\r\n\t});\r\n\tneighborStates.push(MyGame.moveUp.getState());\r\n\tneighborStates.push(MyGame.moveRight.getState());\r\n\tneighborStates.push(MyGame.moveDown.getState());\r\n\tneighborStates.push(MyGame.moveLeft.getState());\r\n\treturn neighborStates;\r\n}\r\n```\r\n\r\nNote, let's say that there is a game-rule (business rule of the game - maybe a wall or something) that is stopping the player from moving up. `The MyGame.moveUp.getState()` call should return a StateObject that has the same `id` as the original state. The A\\* algorithm can then understand that the move resulted in the same state. This is also how the algorithm resolves circular paths. \r\n\r\n##### [optional] heuristic {Function}\r\nA function that accepts a single StateObject as the only parameter and returns an integer - the lower the value, the better. A heuristic is an estimation of \"closeness\" to the end and defaults to a function returning 0 for all states. Read more about the principles of a heuristic here: [wiki](http://en.wikipedia.org/wiki/A*_search_algorithm#Admissibility_and_optimality). For example:\r\n\r\n```\r\nheuristic: function(state) {\r\n\tvar endLocation = MyGame.getEndLocation();\r\n\treturn Math.abs(state.x - endLocation.x) + Math.abs(state.y - endLocation.y)\r\n}\r\n```\r\n\r\n##### [optional] timeout {Integer}\r\nNumber of milliseconds before timeout is called and solving halts. Defaults to no timeout.\r\n\r\n##### onComplete {Function}\r\nFunction that is called once the solution has been found. It accepts a single argument that will have 3 attributes:\r\n\r\n* success {Boolean} if the puzzle was solved\r\n* actions {Array} of `action` attributes of each state to get to solution\r\n* cost {Integer} count of actions needed (actions.length - 1)\r\n\r\n```\r\nonComplete: function(result) {\r\n\tif (result.success) {\r\n\t\tconsole.log(\"The steps(\" + result.cost + \") required to solve the puzzle are: \", result.actions);\r\n\t} else {\r\n\t\tconsole.log(\"There is no solution to the puzzle.\");\r\n\t}\r\n}\r\n```\r\n\r\n##### [optional] onTimeout {Function}\r\nCalled if the solver times out. No parameters needed.\r\n\r\n```\r\nonTimeout: function(){\r\n\tconsole.log(\"Solver timed out.\");\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}